from os.path import join, dirname, realpath, basename
from pickle import loads
from csv import writer, QUOTE_MINIMAL
from optparse import OptionParser

from multiprocessing import Queue, Pool, cpu_count

from android.malicious import methods as suspicious_methods

from androguard.misc import *

from log import log

import sqlite3
import pickle
import glob


data_queue = Queue()

# load classifiers from pickle file
with open('classifier/apicall.pkl', 'rb') as f:
    apicall = pickle.load(f)


with open('classifier/strings.pkl', 'rb') as f:
    suspicious_strings = pickle.load(f)


# seperators
sep_l2 = '|'
sep_l3 = '`'


def analyze_apk_file(apk_file_path):
    """Analyze APK file."""
    apkinfo, dexs, analysis = AnalyzeAPK(apk_file_path)
    return apkinfo, dexs, analysis


def save_certificate(finerprint, self_issued):
    """Save certification information at database when binary is malware."""
    conn = sqlite3.connect('db.sqlite', isolation_level=None)
    cursor = conn.cursor()
    query = "INSERT INTO cert_blacklist(fingerprint, is_self_issued) VALUES(?, ?)"

    try:
        cursor.execute(query, (fingerprint, self_issued))
    except:  # fingerprint already exist
        pass
    finally:
        conn.close()


def extract_feature(file, file_type):
    # todo db에 기본적인 apk 파일에 대한 정보는 캐싱을 해야한다.
    # 필드명: 인증서 정보(fingerprint'self_issued), dexssdeep
    # e.g. fingerprint`self_issued|fingerprint`self_issued
    # 머신 러닝 알고리즘에 진단을 넣기 전에 1차 필터링은 다음과 같이 한다.
    # 다음 조건을 만족하면 무조건 malware
    # 1. 기존 악성 dex 유사도와 분석 대상 dex의 유사도 80%이상이면 30점
    # 2. self_issued가 True이고 fingerprint가 malware_list에 있으면 30점
    # 3. Asset에서 dex, apk 파일이 발견이 되고 system command를 사용을 한다면(20점)
    # 4. 의심스러운 api에 해당 하는 카운트 (총 갯수는 70개인데 모두 맞으면 만점 아니면 뭐 알아서..)
    # ref. https://drive.google.com/file/d/0Bx1Nsg-bc9ovTUlqRUdBVFQ0TkE/view
    # 위 조건 중 하나라도 만족을 하고 머신 러닝에 돌렸을 때 악성으로 나오면 malware로 판단.
    global apicall, suspicious_strings
    file_name = basename(file)
    log().info("analyzing file: {}".format(file_name))

    apkinfo, dexs, analysis = analyze_apk_file(file)

    res = {}

    permissions = apkinfo.get_permissions()
    certificates = apkinfo.get_certificates()

    for feature in features:
        res.setdefault(feature, 0)

    # permissions
    for permission in permissions:
        if permission in res:
            res[permission] = 1

    # extract certificates and insert when binary is malicious
    for certificate in certificates:
        fingerprint = certificate.sha1_fingerprint.replace(' ', ':')
        self_issued = 1 if certificate.self_issued else 0
        if file_type == 1:  # if file is malicious
            # save_certificate(finerprint, self_issued)
            log().debug("{}, fingerprint={}, self_issued={}".format(file_name, fingerprint, self_issued))

    # method call
    methods = analysis.get_methods()
    call_count = {}

    for method in methods:
        if method.is_android_api():
            info = method.get_method()
            name = "{}.{}".format(info.get_class_name()[1:-1].replace('/', '.'), info.name)
            if name in apicall:
                for permission in apicall[name]:
                    if permission in call_count:
                        call_count[permission] += 1
                    else:
                        call_count[permission] = 1

    for key in call_count.keys():
        count = call_count[key]
        name = "{}/method".format(key)
        res[name] = count

    # string sections
    suspicious_string_count = {
        'http': 0,
        'https': 0,
    }

    # todo system command만 별도로 빼본다.
    # system command : mkdir, touch, cat, ...
    # apk -> Asset, res, or lib안에서 확장자랑 미스 매치이고 systme command(파일 생성/ 파일 복사...)
    for dex in dexs:
        for string in dex.get_strings():
            if string in suspicious_strings:
                if string in suspicious_string_count:
                    suspicious_string_count[string] += 1
                else:
                    suspicious_string_count[string] = 1

            # http with startswith
            if string.startswith('http://'):
                suspicious_string_count['http'] += 1

            elif string.startswith('https://'):
                suspicious_string_count['https'] += 1

    for key in suspicious_string_count.keys():
        count = suspicious_string_count[key]
        name = "{}/suspicious_strings".format(key)
        res[name] = count

    # make feature tables
    p = [0] * len(features)
    for idx in range(len(features)):
        p[idx] = res[features[idx]]

    log().info("Successfully extract feature from {} file".format(file_name))

    return p, file_name


def process_file(data):
    global data_queue
    file, file_type = data
    p, file_name = extract_feature(file, file_type)
    p.insert(0, file_name)
    p.insert(1, file_type)

    data_queue.put(p)


if __name__ == '__main__':
    opt_parser = OptionParser()
    opt_parser.set_defaults(inmemory=False, debug=False, UseLocalTimezone=True, UseGUI=False)
    opt_parser.add_option('-t', '--train-data-path',
                          dest='train_data_path',
                          help='Input train data path')

    options, args = opt_parser.parse_args()
    if options.train_data_path is None:
        opt_parser.print_help()
        exit(-1)

    current_module_path = dirname(realpath(__file__))
    with open(join(current_module_path, 'classifier/permissions.pkl'), 'rb') as f:
        features = loads(f.read())

    with open(join(current_module_path, 'classifier/apicall_header.pkl'), 'rb') as f:
        features += loads(f.read())

    with open(join(current_module_path, 'classifier/strings_header.pkl'), 'rb') as f:
        features += loads(f.read())

    log().info('load {} features'.format(len(features)))

    # set train csv file
    csv_file_object = open('train.csv', 'w')
    csv_writer = writer(csv_file_object, delimiter=',', quoting=QUOTE_MINIMAL)

    csv_headers = features.copy()
    csv_headers.insert(0, 'name')
    csv_headers.insert(1, 'type')

    csv_writer.writerow(csv_headers)

    malware_data_path = join(options.train_data_path, '1-malware')

    """
    pool = Pool(processes=cpu_count() * 2)
    pool.map(
        process_file,
        [[filepath, 1] for filepath in glob.glob('{}/*.vir'.format(malware_data_path))])

    normal_data_path = join(options.train_data_path, '0-normal')

    pool.map(
        process_file,
        [[filepath, 0] for filepath in glob.glob('{}/*.vir'.format(normal_data_path))])
    """

    process_file([glob.glob('{}/*.vir'.format(malware_data_path))[10], 1])

    while not data_queue.empty():
        csv_writer.writerow(data_queue.get())

    log().info('Successfully done:-')
    csv_file_object.close()
