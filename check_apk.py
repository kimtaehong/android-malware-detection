import glob
import sqlite3

from optparse import OptionParser
from os.path import isdir, join, exists, dirname, realpath, basename
from multiprocessing import Pool, cpu_count, Queue
from pickle import loads, load
from androguard.misc import *

from android.malicious import methods as suspicious_methods
from android.malicious import commands as suspicious_commands
from log import log

data_queue = Queue()


# permission에 대응되는 api 리스트를 pickle 파일에서 가져온다
with open('classifier/apicall.pkl', 'rb') as f:
    apicall = load(f)


# 의심스러운 string들을 pickle 파일에서 가져온다
with open('classifier/strings.pkl', 'rb') as f:
    suspicious_strings = load(f)


def find_apk_files(dir_path: str, file_pattern='*.vir'):
    apk_files = []
    for file_path in glob.glob('{}/{}'.format(dir_path, file_pattern)):
        apk_files.append(file_path)
    return apk_files


def check_black_serial_number(cursor, fingerprint):
    sql = 'select count(*) as cnt from cert_blacklist where fingerprint=?'
    cursor.execute(sql, (fingerprint,))
    if cursor.fetchone()[0] == 0:
        return False
    return True


# todo. dexs 유사도 비교 코드를 작성해야한다.
def check_apk_similarity(cursor, dexs):
    return False


def check_apk_certificates(cursor, certificates):
    # extract certificates and insert when binary is malicious
    is_black_serial_number = False
    for certificate in certificates:
        fingerprint = certificate.sha1_fingerprint.replace(' ', ':')
        is_black_serial_number = check_black_serial_number(cursor, fingerprint)
        if is_black_serial_number:
            break
    return is_black_serial_number


# todo extract_feature 코드 확인 필요.(요청: 남준)
def extract_feature(apkinfo, dexs, analysis):
    global apicall, suspicious_strings
    res = {}

    permissions = apkinfo.get_permissions()
    certificates = apkinfo.get_certificates()

    for feature in features:
        res.setdefault(feature, 0)

    # permissions
    for permission in permissions:
        if permission in res:
            res[permission] = 1

    # method call
    methods = analysis.get_methods()
    call_count = {}

    for method in methods:
        if method.is_android_api():
            info = method.get_method()
            name = "{}.{}".format(info.get_class_name()[1:-1].replace('/', '.'), info.name)
            if name in apicall:
                for permission in apicall[name]:
                    if permission in call_count:
                        call_count[permission] += 1
                    else:
                        call_count[permission] = 1

    for key in call_count.keys():
        count = call_count[key]
        name = "{}/method".format(key)
        res[name] = count

    # string sections 처리
    # 의심 string 발견 count
    suspicious_string_count = {
        'http': 0,
        'https': 0,
    }

    # 의심 method 발견 여부 (0, 1)
    suspicious_method_table = {}

    # 의심 command 발견 여부
    suspicious_command_table = {}

    # apk -> Asset, res, or lib안에서 확장자랑 미스 매치이고 systme command(파일 생성/ 파일 복사...)
    for dex in dexs:
        for string in dex.get_strings():
            # 의심 string 작업
            if string in suspicious_strings:
                if string in suspicious_string_count:
                    suspicious_string_count[string] += 1
                else:
                    suspicious_string_count[string] = 1

            # http 로 시작하는 string이 존재 하는지 확인
            if string.startswith('http://'):
                suspicious_string_count['http'] += 1

            elif string.startswith('https://'):
                suspicious_string_count['https'] += 1

            # 의심 method 처리
            if string in suspicious_methods:
                suspicious_method_table[string] = 1

            # 의심 command 처리
            if string in suspicious_commands:
                suspicious_command_table[string] = 1

    # header와 mapping 하기 위하여 변경된 name으로 res에 넣기
    for key in suspicious_string_count.keys():
        count = suspicious_string_count[key]
        name = "{}/suspicious_strings".format(key)
        res[name] = count

    for key in suspicious_method_table.keys():
        name = "{}/suspicious_methods".format(key)
        res[name] = 1

    for key in suspicious_command_table.keys():
        name = "{}/suspicious_commands".format(key)
        res[name] = 1

    # make feature tables
    p = [0] * len(features)
    for idx in range(len(features)):
        p[idx] = res[features[idx]]

    return p


# todo. 탐지 모델을 적용해야한다.
def predict(apk_feature):
    return False


def do_apk_analysis(apk_file_path: str):
    apkinfo, dexs, analysis = AnalyzeAPK(apk_file_path)
    return apkinfo, dexs, analysis


def check_apk(cursor, apk_file_path):
    apkinfo, dexs, analysis = do_apk_analysis(apk_file_path)

    is_malicious_apk = False

    # check similarity
    is_similarity = check_apk_similarity(cursor, dexs)

    # check certificates
    certificates = apkinfo.get_certificates()
    is_match_black_serialnumber = check_apk_certificates(cursor, certificates)

    apk_feature = extract_feature(apkinfo, dexs, analysis)
    if is_match_black_serialnumber:
        is_malicious_apk = True
        return is_malicious_apk
    else:
        apk_feature = extract_feature(apkinfo, dexs, analysis)
        is_malicious_apk = predict(apk_feature)
    return is_malicious_apk


def load_features():
    current_module_path = dirname(realpath(__file__))
    features = None
    with open(join(current_module_path, 'classifier/permissions.pkl'), 'rb') as f:
        features = loads(f.read())

    with open(join(current_module_path, 'classifier/apicall_header.pkl'), 'rb') as f:
        features += loads(f.read())

    with open(join(current_module_path, 'classifier/strings_header.pkl'), 'rb') as f:
        features += loads(f.read())

    features += ["{}/suspicious_methods".format(method) for method in suspicious_methods]

    features += ["{}/suspicious_commands".format(command) for command in suspicious_commands]

    log().info('load {} features'.format(len(features)))

    return features


def main(apk_file_path_list):
    conn = sqlite3.connect('db.sqlite', isolation_level=None)
    cursor = conn.cursor()
    # todo 결과 파일을 저장 할 수 있도록 해야한다.
    for apk_file in apk_file_path_list:
        is_malicious_apk = check_apk(cursor, apk_file)
    log().info('Successfully done:-')


if __name__ == '__main__':
    opt_parser = OptionParser()
    opt_parser.set_defaults(inmemory=False, debug=False, UseLocalTimezone=True, UseGUI=False)
    opt_parser.add_option('-t', '--target-apk-path',
                          dest='target_apk_path',
                          help='Input target apk path')

    options, args = opt_parser.parse_args()
    if options.target_apk_path is None:
        opt_parser.print_help()
        exit(-1)
    if exists(options.target_apk_path) is False:
        log().error("Invalid Path - Not Exists.")
        exit(-1)

    features = load_features()

    apk_files = []
    if isdir(options.target_apk_path) is True:
        apk_files += find_apk_files(options.target_apk_path)
    else:
        apk_files.append(options.target_apk_path)
    if len(apk_files) == 0:
        log().error("apk file path invalid. check apk path.")
    main(apk_files)
